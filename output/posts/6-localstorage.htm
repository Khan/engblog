<!DOCTYPE html> <html> <head> <title>John CS - Local storage today</title> <meta http-equiv="Content-Type" content="text/html;charset=utf-8"> <meta name="description" content="An audit of recent local storage implementations in Firefox, WebKit, and Chromium."> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!--inject:head:css--> <style>#post-title,h2{font-weight:400}#comments,#draft-bar,#end-bits,#top-header{text-align:center}.c,.c1,.cm,.cs,.ge{font-style:italic}#draft-bar{position:fixed;bottom:0;left:0;right:0;background-color:#EEA;padding:1em}#post-body{margin:0 auto;line-height:1.5;max-width:50em}#post-body img,#top-header,table.footnote:first-of-type{margin-top:2em}#top-header{margin-bottom:4em}#post-title{font-size:2em;line-height:1.5;letter-spacing:.08em;margin-bottom:.4em}h2{letter-spacing:.07em}#post-body img{max-width:100%;margin-bottom:2em}table.footnote{font-size:.8em}pre,tt{font-family:'Courier New',Courier,'Lucida Sans Typewriter','Lucida Typewriter',monospace}pre{padding-left:1em}.red-bold{color:red;font-weight:700}#end-bits{margin:3em 0 1em;font-size:1.25em}#end-bits a{white-space:nowrap}#comments{color:#AAA}body{font-family:'Helvetica Neue',Helvetica,Arial,sans-serif;background-color:#FEFEFE;color:#161616;padding-bottom:5em;margin:0;font-size:16px}.bounded{padding:0 2em}@media (min-width:1500px){body{font-size:19px}}@media (max-width:1000px){body{font-size:15px}}@media (max-width:300px){body{font-size:11px}}b,strong{font-weight:600}a{text-decoration:none;color:#778A2D}a:hover{text-decoration:underline}#content .pure-form fieldset,#content .pure-form legend{border-bottom:none}a.pure-button-primary,button.pure-button-primary{background-color:#5CADB5;font-weight:600}.cp,.cs,.gs,.k,.kc,.kd,.kn,.kp,.kr,.kt,.nc,.ne,.nf,.o,.ow{font-weight:700}.faded{opacity:.7}.align-center{display:block;margin:0 auto}.hll{background-color:#ffc}.c{color:#998}.err{color:#a61717;background-color:#e3d2d2}.cm{color:#998}.cp{color:#999}.c1{color:#998}.cs{color:#999}.gd{color:#000;background-color:#fdd}.gr{color:#a00}.gh{color:#999}.gi{color:#000;background-color:#dfd}.go{color:#888}.gp{color:#555}.gu{color:#aaa}.gt{color:#a00}.kt{color:#458}.m{color:#099}.s{color:#b84}.na{color:teal}.nb{color:#999}.nc{color:#458}.no{color:teal}.ni{color:purple}.ne,.nf{color:#900}.nn{color:#555}.nt{color:navy}.nv{color:teal}.w{color:#bbb}.mf,.mh,.mi,.mo{color:#099}.s2,.sb,.sc,.sd,.se,.sh,.si,.sx{color:#b84}.sr{color:olive}.s1,.ss{color:#b84}.bp{color:#999}.vc,.vg,.vi{color:teal}.il{color:#099}</style> <!--endinject--> </head> <body id="post-page"> <header id="top-header"> <h1 id="post-title"> <a href="/">John CS</a>: Local storage today </h1> <div id="post-metadata" class="faded"> Posted December 22, 2014 </div> </header> <div id="post-body"> <div class="document"> <p>I&apos;d like to write to <tt class="docutils literal">localStorage</tt> often. I&apos;d also like to write to it synchronously in response to user interaction.</p> <p>Past wisdom says this is a bad idea and will give me Angry Users Syndrome very quickly. Bad ideas are fun though, so let&apos;s see how much of a bad idea it is.</p> <p>TL;DR: It&apos;s not a bad idea for (at least) the latest Firefox, WebKit, and Chromium browsers. <tt class="docutils literal">localStorage.setItem</tt> and <tt class="docutils literal">localStorage.getItem</tt> access fast in-memory data structures and updating the disk is done asynchronously in the background.</p> <p>To get an idea of what we&apos;re looking at, let&apos;s take a quick dip into Firefox&apos;s source code (<a class="reference external" href="https://github.com/mozilla/gecko-dev">you can follow along on GitHub</a>). I&apos;m starting from the top of the C++ implementation of <tt class="docutils literal">localstorage.setItem</tt> which is at <tt class="docutils literal"><span class="pre">DOMStorage::SetItem</span></tt> in <tt class="docutils literal">dom/storage/DOMStorage.cpp</tt>. There&apos;s nothing interesting in that function, but one layer deeper at <tt class="docutils literal"><span class="pre">DOMStorageCache::SetItem</span></tt> in <tt class="docutils literal">dom/storage/DOMStorageCache.cpp</tt> we get something interesting.</p> <p>Below is the entirety of the function with my own comments. Sorry in advance for shoving a bunch of C++ at you&#x2026;</p> <pre class="code cpp literal-block">
<span class="c1">// Firefox loads all existing localStorage data from the disk the first
// it hits your site. If that operation hasn&apos;t finished yet, we get to
// twiddle our thumbs for a bit.
</span><span class="k">if</span> <span class="p">(</span><span class="n">Persist</span><span class="p">(</span><span class="n">aStorage</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">WaitForPreload</span><span class="p">(</span><span class="n">Telemetry</span><span>::</span><span class="n">LOCALDOMSTORAGE_SETVALUE_BLOCKING_MS</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">NS_FAILED</span><span class="p">(</span><span class="n">mLoadResult</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">mLoadResult</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// data is an in-memory hash table containing all of our localStorage
// data, so this is blazing fast.
</span><span class="n">Data</span><span>&amp;</span> <span class="n">data</span> <span>=</span> <span class="n">DataSet</span><span class="p">(</span><span class="n">aStorage</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span>!</span><span class="n">data</span><span class="p">.</span><span class="n">mKeys</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="n">aKey</span><span class="p">,</span> <span>&amp;</span><span class="n">aOld</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">SetDOMStringToNull</span><span class="p">(</span><span class="n">aOld</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Make sure the quota isn&apos;t going to be exeeded. Nothing terribly
// interesting here.
</span><span class="k">const</span> <span class="kt">int64_t</span> <span class="n">delta</span> <span>=</span> <span class="k">static_cast</span><span>&lt;</span><span class="kt">int64_t</span><span>&gt;</span><span class="p">(</span><span class="n">aValue</span><span class="p">.</span><span class="n">Length</span><span class="p">())</span> <span>-</span>
                      <span class="k">static_cast</span><span>&lt;</span><span class="kt">int64_t</span><span>&gt;</span><span class="p">(</span><span class="n">aOld</span><span class="p">.</span><span class="n">Length</span><span class="p">());</span>
<span class="k">if</span> <span class="p">(</span><span>!</span><span class="n">ProcessUsageDelta</span><span class="p">(</span><span class="n">aStorage</span><span class="p">,</span> <span class="n">delta</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">NS_ERROR_DOM_QUOTA_REACHED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">aValue</span> <span>==</span> <span class="n">aOld</span> <span>&amp;&amp;</span> <span class="n">DOMStringIsNull</span><span class="p">(</span><span class="n">aValue</span><span class="p">)</span> <span>==</span> <span class="n">DOMStringIsNull</span><span class="p">(</span><span class="n">aOld</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">NS_SUCCESS_DOM_NO_OPERATION</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Update the in-memory hash table.
</span><span class="n">data</span><span class="p">.</span><span class="n">mKeys</span><span class="p">.</span><span class="n">Put</span><span class="p">(</span><span class="n">aKey</span><span class="p">,</span> <span class="n">aValue</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">Persist</span><span class="p">(</span><span class="n">aStorage</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span>!</span><span class="n">sDatabase</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NS_ERROR</span><span class="p">(</span><span>&quot;Writing to localStorage after the database has been shut down&quot;</span>
             <span>&quot;, data lose!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">NS_ERROR_NOT_INITIALIZED</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Asynchonously update the disk.
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">DOMStringIsNull</span><span class="p">(</span><span class="n">aOld</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">sDatabase</span><span>-&gt;</span><span class="n">AsyncAddItem</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">aKey</span><span class="p">,</span> <span class="n">aValue</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">sDatabase</span><span>-&gt;</span><span class="n">AsyncUpdateItem</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">aKey</span><span class="p">,</span> <span class="n">aValue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">NS_OK</span><span class="p">;</span>
</pre> <p>The corresponding <tt class="docutils literal">localStorage.getItem</tt> implementation is even simpler and just accesses that hash table (it&apos;s in the same file if you want to take a look).</p> <p>So to summarize: whenever we access <tt class="docutils literal">localStorage</tt> we&apos;re accessing a hash table and we&apos;re not going to block on the disk, unless we haven&apos;t finished the initial preload.</p> <p>This is nice news and I like this, but there&apos;s quite a few browsers out there. Let&apos;s take a look at Chromium next (<a class="reference external" href="https://chromium.googlesource.com/chromium/src.git/+/master">follow along on Google Code</a>).</p> <p><tt class="docutils literal"><span class="pre">WebStorageAreaImpl::setItem</span></tt> at <tt class="docutils literal">src/content/renderer/dom_storage/webstoragearea_impl.cc</tt> is the top of the C++ implementation, but again it doesn&apos;t have anything interesting. We need to dig down to <tt class="docutils literal"><span class="pre">DOMStorageCachedArea::SetItem</span></tt> in <tt class="docutils literal">src/content/renderer/dom_storage/dom_storage_cached_area.cc</tt> in order to see something cool (comments by me again):</p> <pre class="code cpp literal-block">
<span class="c1">// A quick check to reject obviously overbudget items to avoid
// the priming the cache.
</span><span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span>+</span> <span class="n">value</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span>&gt;</span> <span class="n">kPerStorageAreaQuota</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

<span class="c1">// Similarily to Firefox, we load everything on disk into memory. It
// doesn&apos;t look like preloading is automatically triggered when users hit
// your site though, and must be manually initiated by accessing local
// storage.
</span><span class="n">PrimeIfNeeded</span><span class="p">(</span><span class="n">connection_id</span><span class="p">);</span>

<span class="c1">// map_ is (basically) a std::map object, which is going to be some data
// structure that lets you do this operation in O(log n) time.
</span><span class="n">base</span><span>::</span><span class="n">NullableString16</span> <span class="n">unused</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span>!</span><span class="n">map_</span><span>-&gt;</span><span class="n">SetItem</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span>&amp;</span><span class="n">unused</span><span class="p">))</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

<span class="c1">// Ignore mutations to &apos;key&apos; until OnSetItemComplete.
</span><span class="n">ignore_key_mutations_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span>++</span><span class="p">;</span>

<span class="c1">// Asynchronously update the disk.
</span><span class="n">proxy_</span><span>-&gt;</span><span class="n">SetItem</span><span class="p">(</span>
    <span class="n">connection_id</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">page_url</span><span class="p">,</span>
    <span class="n">base</span><span>::</span><span class="n">Bind</span><span class="p">(</span><span>&amp;</span><span class="n">DOMStorageCachedArea</span><span>::</span><span class="n">OnSetItemComplete</span><span class="p">,</span>
               <span class="n">weak_factory_</span><span class="p">.</span><span class="n">GetWeakPtr</span><span class="p">(),</span> <span class="n">key</span><span class="p">));</span>
<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</pre> <p>The corresponding <tt class="docutils literal">localStorage.getItem</tt> implementation just accesses the <tt class="docutils literal"><span class="pre">std::map</span></tt> object.</p> <p>To summarize: Chromium behaves the same as Firefox except that it does not seem to preload the cache until you hit local storage for the first time.</p> <p>WebKit seems like a good next target (<a class="reference external" href="https://github.com/WebKit/webkit">github</a>). <tt class="docutils literal"><span class="pre">Storage::setItem</span></tt> in <tt class="docutils literal">Source/WebCore/storage/Storage.cpp</tt> is the top of the implementation, and it does have something interesting for once. We can see that <a class="reference external" href="http://stackoverflow.com/a/14555361/3920202">private browsing mode kills localStorage</a>. Burying deeper down though we see a similar story at <tt class="docutils literal"><span class="pre">StorageAreaMap::setItem</span></tt> in <tt class="docutils literal">Source/WebKit2/WebProcess/Storage/StorageAreaMap.cpp</tt>.</p> <p>I&apos;m not going to paste the code here because it&apos;s basically the same as the above two. There&apos;s the wait on the preload, then an access to an in-memory data structure (a hash table this time), and then an asynchronous call to update the disk.</p> <p>It would be a good idea to go back through the git history of the three repositories I&apos;ve been looking at to see when they became super fast. I&apos;d also like to do some testing to Internet Explorer to try and figure out if its implementation is also fast. I&apos;ll leave that to another post though.</p> </div> </div> <div id="end-bits"> <a href="/">see all posts</a> - <a href="/rss.xml">subscribe with RSS</a> </div> <div id="comments"> (comments are temporarily unavailable) </div> <script>!function(e,n,a,t,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=n.createElement(a),s=n.getElementsByTagName(a)[0],o.async=1,o.src=t,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-51104787-1","johncs.com"),ga("send","pageview");</script> </body> </html> 